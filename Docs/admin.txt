================ ВНИМАНИЕ!!! ===================================
Имена переменных в контроллерах передоваемых в шаблоны имеют значение!

$item - для редактирования текущий объект
$item->langs - мультиязычное содержание
$items - для ленты(списка) объектов или список для помощи при редактировании(без потомков)
$items_with_children - для помощи при редактировании список объектов с потомками если есть такие(необязательно из текущей модели)
$excluded_fields - запретить поля для вывода
$tabs - вкладки(табы) с колонками для интерфейса редактирования сущности
$columns - динамические колонки для отображения в интерфейсе адмики из модели *Columns (для попапа)
$global_columns - тоже самое, что и $columns, но расшаренные для всех шаблонов. Иногда при глубокой
    вложенности переменная $columns может быть не видна, тогда стоит использовать $global_columns.
=============================================================================
Идеология.

Большинство миграций, контроллеров, моделей имеют одинаковую или очень похожую структуру.
Не хотелось бы переписывать код за каждым разом. Возможно надо выучить [CTRL + C], [CTRL + V] и всё?
Нет не всё. Ещё [SHIFT + F6] для PhpStorm.

Во фреймворке Laravel в стандартном rest-контроллере используются методы:
index, create, store, edit, update, destroy.
Во всех методах из перечисленных(за исключением index) идёт работа с одним объектом.
Это может быть товар или запись, или статья и т.д. соответственно некий объект может иметь универсальное название "item".
Для этих же методов могут понадобиться для вспомогательных целей список объектов другого типа или
список объектов другого типа с потомками, соответственно можно дать им название "items" или "items_with_children"
например список категорий при редактировании товара.
В методе "index" будут использоваться списки с потомками или без. Для универсальности
можно оставить названия переменных те же "items" и/или "items_with_children".
И так. Имея всего три имени переменных можно покрыть большинство однотипных задач.
Плюс такого подхода заключается в том, что не надо плодить шаблоны отображения(*.blade.php)
т.к. в шаблонах будут одни и теже переменные.
Проще запомнить систему именования переменных или каждый раз писать шаблон(*.blade.php)?
Так же могут быть добавлены и другие служебные переменные требующиеся во всех шаблонах.
В дополнение создаются шаблоны для каждого поля из БД.
Одно поле - один шаблон. И тут опять чтобы не плодить шаблоны создаём тип поля т.к. поля могут быть разными,
а тип одинаковым. Например, поля "title" и "name" могут иметь тип и шаблон "string",
"description" и "announce" могут иметь тип и шаблон "text" и т.д.

Схема использования имён переменных
index => [
    собственные_объекты => items/items_with_children
]
create/store/edit/update/destroy => [
    собственный_объект => item,
    вспомогательные_объекты => items/items_with_children
]
Важно понимать, что не надо прилепливать посторонний функционал в одну кучу. Это надо делать либо через зависимость,
либо на отдельной странице. Архитектура наше всё!

Расширение функционала.
-----------------------

Если необходим функционал который есть в другой сущности достаточно скопировать его с переименованием классов и/или файлов.
Если нужного функционала нет, то разработка может вестись как на обычном Laravel.
=============================================================================

Добавление кастомного поля в форму редактирования сущности на примере "Email".

0. Добавить колонку email в таблицу например через phpMyAdmin

1. Добавить запись в таблицу *_columns
    origin_name - название колонки в таблице сущности (email) (string)
    type - название шаблона для поля, возможно вложенность через "." (string)
    show_name - название отображаемое в админке (string)
    sort_list - сортировка в ленте (int)
    sort_single - сортировка на детальной странице (int)
    is_show_anons - показывать ли в ленте (bool)
    is_show_single - показывать ли на детальной (bool)

2. Создать новый или использовать существующий шаблон "resources/views/admin/parts/form/type/email".
    [type - из первого пункта]

3. Если колонка email добавляется в связную таблицу то надо добавить зависимость в модель
    $product = Product::with(['field_name'])->...
    или
    добавить свойство в $product
    $product->setAttribute('field_name', null);
    Не обязательно, но желательно добавлять зависимость в модель. Это может повлиять на разработку шаблонов полей.
    В шаблоне обращатся к нужной переменной возможно как
    $item->field_name или $field_name.
    Очевидно, что когда field_name находится внутри $item это создаёт некоторое пространство имён и случайная перезапись
    field_name менее вероятна.

4. Добавить поле в контроллере или в App\Http\Controllers\AdminController::base_fields().
   Например:
   if ($request->has('email')){
     $data['email'] = $request->input('email');
   }
   а так же валидацию в App\Http\Requests\******Request
   Наследование классов валидации:
   MetaGeneralRequest <- Store***Request <- Update***Request
=====================================================================================
Вложенность шаблонов
1. index.blade.php -> parts/index_template.blade.php
2. edit.blade.php -> parts/form_edit.blade.php -> parts/form/type/type.blade.php
3. create.blade.php -> parts/form_edit.blade.php -> parts/form/type/type.blade.php
=====================================================================================
